# Rethinking model view controller

While trying to nail down some of the finer points of a model view controller, I organized the code into layers where each layer sort of pertained to an aspect of mvc. One thing that this truly helped was to clarify how layering code is a really good method of organization. I've always known about layering, and I've been doing layering all along, but this exercise brought several of the concepts to the forefront. So I am happy with taking away from the exercise that using layers, or rather, seeing the layers more explicitly, is a good thing.

However, there are several aspects of this attempt at MVC that do not sit well with me. The assignment of the functionality into some of the layers feels less than perfect. In fact, it feels downright arbitrary. So now I am rethinking this. Despite what I see in various frameworks and other projects (which make me seriously doubt what I am about to say), I think that the current attempt at MVC-style organization was wrong.

First, the model layer isn't the model itself. Much like how ORM code is not the database itself. The database *itself* is the model. The layer of code that writes data to the database and reads data from the database is just a sort of end-point layer for interacting with the database. It is not necessarily above or below other layers. It is not a *model* within itself. It is just a proxy of sorts, a kind of mediator, through which the rest of the application interacts with the database. Code that interacts with the database is just more control code.

Second, and similar to the preceding point, was the views folder containing all the page scripts. This too, the view code, was not actually the V in MVC. The view here in the browser extension is the browser itself. It is the console, it is the HTML, it is the DOM itself. Code that interacts with the DOM is not the view in of itself, it is just code that interacts with the view. In other words, it is just more control code.

What this basically means is that my attempt at isolating the various modules into the different layers, while useful, was incorrect. So, what I plan to do is slowly unroll a bunch of this organization. In the next design, I should recognize that all script is control script. I still have scripts that depend on other scripts. There are still layers. Not everything interacts with the view or the database. However, any control code can do either. So I want to end up with a big network of dependencies.

In the new design, the layering of modules will be implicit. Instead of imposing layer constraints by organizing the modules into explicit layer-aligned folders, everything will be independent. The only way to then perceive the layering will be through the names of modules, or by examining the dependencies within the module (examining the import statements at the top).

Therefore, in this new design, because every module's location is independent of its implicit layer, this means that I should in general reorganize what modules represent. This involves several changes. For example, the model layers should not be called model layers. The model modules are just controllers that interact with the model. Similarly the view modules are just controllers that interact with the view. Furthermore, the controller code no longer needs controller in its name, because everything is a controller.

Another thing to think about during this transition is reconsidering the separation of the lib folder from the glue code. Once I get a flat set of independent modules, there may not be a need to distinguish app code from library code. Everything is a library. Even library code are controllers to some degree. Or maybe not. Not really sure. But it is really hard to separate out what is app-control code and what is library code in a few places. I am not sure that distinguishing between the two is worth it. The difference feels kind of arbitrary.

To sum up, I plan to make the following changes:

* unwrap the model layer, or reorient as just a set of controllers, or as just utility code for other controllers, like a storage-utils module, or just a general persistence-layer kind of thing (that should not be confused with the M in MVC).
* revisit whether feed functionality should have been merged with entry functionality in the model modules, it is possible that grouping them together was wrong
* revisit whether model-related code really depends in its own layer coupled together. if updating an entry has nothing to do with updating a feed or reading in a list of entries, then these things should not be grouped together at all. similarly, there may not even be a need to try and encapsulate away indexedDB everything. group things that change together into the same module. the only reason to separate out indexedDB specific code from other stuff is if it is actually reused across modules. it should not be separated out just because it feels weird to group model-updating code together with view or control related code. then again, SOLID. Totally unsure. The thing is, I am not going to do something like swap out the db platform suddenly. Why try and abstract it away?
* unwrap the control folder
* unwrap the library folder
* unqualify control module names as everything is a controller
* eventually focus more on just organizing the set of controllers and helper libraries so that everything is as independent and decoupled and as substitutable as possible. for example, if a controller relies on a library, and that is the only place where that library is used, maybe that library should just be a helper to the controller instead of as a standalone library
