import assert from "/src/assert.js";
import FaviconCache from "/src/favicon/cache.js";
import * as OPMLDocument from "/src/opml/document.js";
import * as OPMLOutline from "/src/opml/outline.js";
import parseOPML from "/src/opml/parse.js";
import * as Subscriber from "/src/reader/subscribe.js";
import * as Feed from "/src/reader-db/feed.js";
import openReaderDb from "/src/reader-db/open.js";
import * as idb from "/src/utils/indexeddb-utils.js";
import * as mime from "/src/utils/mime-utils.js";
import promiseEvery from "/src/utils/promise-every.js";


// Import opml files
// @param files {FileList} a collection of File objects, such as one generated by an HTML input
// element after browsing for files
export default async function main(files) {
  assert(files instanceof FileList);
  console.debug('importing %d files', files.length);

  const fic = new FaviconCache();
  let readerConn;
  try {
    [readerConn] = await Promise.all([openReaderDb(), fic.open()]);
    const promises = [];
    for(const file of files) {
      promises.push(importFile(file, readerConn, fic));
    }
    await promiseEvery(promises);
  } finally {
    fic.close();
    idb.close(readerConn);
  }
}

async function importFile(file, readerConn, iconCache) {
  assert(file instanceof File);
  assert(idb.isOpen(readerConn));
  assert(iconCache.isOpen());
  console.log('importing opml file', file.name);

  if(file.size < 1) {
    console.log('file %s is 0 bytes', file.name);
    return 0;
  }

  if(!mime.isXML(file.type)) {
    console.log('file %s is not mime type xml', file.type);
    return 0;
  }

  let fileContent;
  try {
    fileContent = await readFileAsText(file);
  } catch(error) {
    console.warn(error);
    return 0;
  }

  const document = parseOPML(fileContent);
  removeOutlinesWithInvalidTypes(document);
  normalizeOutlineXMLURLs(document);
  removeOutlinesMissingXMLURLs(document);

  const outlines = OPMLDocument.getOutlineObjects(document);
  if(!outlines.length) {
    console.log('file %s contained 0 outlines', file.name);
    return 0;
  }

  const uniqueOutlines = groupOutlines(outlines);
  const dupCount = outlines.length - uniqueOutlines.length;
  console.log('found %d duplicates in file', dupCount, file.name);

  for(const outline of uniqueOutlines) {
    OPMLOutline.normalizeHTMLURL(outline);
  }

  const feeds = [];
  for(const outline of uniqueOutlines) {
    feeds.push(outlineToFeed(outline));
  }

  const subscribeContext = new Subscriber.Context();
  subscribeContext.readerConn = readerConn;
  subscribeContext.iconConn = iconCache.conn;
  subscribeContext.fetchFeedTimeoutMs = timeoutMs;
  subscribeContext.notify = false;

  const subcribePromises = feeds.map(Subscriber.subscribe, subscribeContext);
  const subscribeResults = await promiseEvery(subscribePromises);
  console.log('subbed to %d feeds in file', subscribeResults.length, file.name);
}

function removeOutlinesWithInvalidTypes(doc) {
  assert(doc instanceof Document);
  const elements = OPMLDocument.getOutlineElements(doc);
  for(const element of elements) {
    if(!OPMLOutline.elementHasValidType(element)) {
      element.remove();
    }
  }
}

function normalizeOutlineXMLURLs(doc) {
  assert(doc instanceof Document);
  const outlines = OPMLDocument.getOutlineElements(doc);
  for(const outline of outlines) {
    OPMLOutline.elementNormalizeXMLURL(outline);
  }
}

function removeOutlinesMissingXMLURLs(doc) {
  assert(doc instanceof Document);
  const outlines = OPMLDocument.getOutlineElements(doc);
  for(const outline of outlines) {
    if(!OPMLOutline.elementHasXMLURL(outline)) {
      outline.remove();
    }
  }
}

// Filter duplicates, favoring earlier in array order
function groupOutlines(outlines) {
  const uniqueURLs = [];
  const uniqueOutlines = [];
  for(const outline of outlines) {
    if(!uniqueURLs.includes(outline.xmlUrl)) {
      uniqueOutlines.push(outline);
      uniqueURLs.push(outline.xmlUrl);
    }
  }
  return uniqueOutlines;
}

// Convert an outline object into a feed
function outlineToFeed(outline) {
  assert(OPMLOutline.isOutline(outline));

  // Note that this uses create, not a simple object, to allow magic to happen
  const feed = Feed.create();

  if(outline.type) {
    feed.type = outline.type;
  }

  if(outline.title) {
    feed.title = outline.title;
  }

  if(outline.text) {
    feed.text = outline.text;
  }

  if(outline.description) {
    feed.description = outline.description;
  }

  if(outline.htmlUrl) {
    feed.link = outline.htmlUrl;
  }

  Feed.appendURL(feed, outline.xmlUrl);
  return feed;
}

// Returns a promise that resolves to the full text of a file
function readFileAsText(file) {
  return new Promise(function executor(resolve, reject) {
    assert(file instanceof File);
    const reader = new FileReader();
    reader.readAsText(file);
    reader.onload = () => resolve(reader.result);
    reader.onerror = () => reject(reader.error);
  });
}
