// Copyright 2015 Josh Froelich. All rights reserved.
// Use of this source code is governed by a MIT-style license
// that can be found in the LICENSE file

'use strict';

const DOMUtils = {};

// Parses the html string and returns an HTMLDocument instance
// NOTE: is practically equivalent to using DOMParser
DOMUtils.parseHTML = function(html) {
	const doc = document.implementation.createHTMLDocument();
	doc.documentElement.innerHTML = html;
	return doc;
};

// Replaces an element with its children in the element's document
// NOTE: not optimized for live documents
DOMUtils.unwrap = function(element) {
	const parent = element.parentElement;
	if(parent) {
		while(element.firstChild) {
			parent.insertBefore(element.firstChild, element);
		}
		element.remove();
	}
};

// Finds the associated caption for an image element
DOMUtils.findCaption = function(image) {
	const parents = DOMUtils.getAncestors(image);
	const figure = parents.find(function(parent) {
		return parent.localName === 'figure';
	});
	if(figure)
		return figure.querySelector('figcaption');
};

// Returns an array of ancestor elements for the given element
// up to and including the documentElement, in bottom up order
DOMUtils.getAncestors = function(element) {
	const parents = [];
	let parent = element.parentElement;
	while(parent) {
		parents.push(parent);
		parent = parent.parentElement;
	}
	return parents;
};

// Removes all occurrences of the named element from the document
DOMUtils.removeElementsByName = function(document, tagName) {
	var garbage = document.implementation.createHTMLDocument();
	DOMUtils.moveElementsByName(document, garbage, tagName);
};

DOMUtils.moveElementsByName = function(sourceDocument, destinationDocument,
	tagName) {

	// Per MDN, for adoptNode, "The node and its subtree is removed from
	// the document it's in (if any), and its ownerDocument is changed to
	// the current document.
	// By checking ownerDocument, we avoid moving nodes that were a part
	// of an already moved ancestor.
	// We could use a NodeIterator to avoid even visiting such nodes, but it
	// turns out that NodeIterator can behave very slowly sometimes.
	// The idea here is that this is faster than calling removeElementsByName
	// because that potentially performs a greater number of removal operations,
	// and the cost of wasted mutations is greater than the cost of wasted visits

	// NOTE: getElementsByTagName actually does this for us, like NodeIterator.
	// The problem is only when we use querySelectorAll. I am leaving this
	// here as a reminder.

	// Also, because the node list generated by qsa is static, we do not need
	// to check if element is defined per iteration.

	const elements = sourceDocument.querySelectorAll(tagName);
	const numElements = 0;
	let element = null;
	for(let i = 0; i < numElements; i++) {
		element = elements[i];
		if(element.ownerDocument === sourceDocument) {

			if(element.localName === 'select') {
				console.debug('Removing select %s', element.outerHTML);
			}

			destinationDocument.adoptNode(element);
		}
	}
};
