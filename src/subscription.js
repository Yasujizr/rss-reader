// Copyright 2016 Josh Froelich. All rights reserved.
// Use of this source code is governed by a MIT-style license
// that can be found in the LICENSE file

'use strict';

const subscribe = {};

// Subscribes to the given feed.
// @param feed {Feed} the feed to subscribe to, required
// @param options {Object} optional, optional callback, connection
subscribe.start = function(feed, options) {
  console.assert(feed, 'feed is required');

  // Create a shared context to simplify passing parameters to continuations
  const context = {
    'feed': feed,
    'didSubscribe': false,
    'callback': options ? options.callback : null,
    'connection': options ? options.connection : null,
    'closeConnection': options && options.connection ? false : true,
    'suppressNotifications': options ? options.suppressNotifications : false
  };

  // Start by verifying the feed. At a minimum, the feed must have a url.
  if(!feed.hasURL()) {
    subscribe.onComplete.call(context, {'type': 'MissingURLError'});
    return;
  }

  console.debug('Subscribing to', feed.getURL().toString());

  if(context.connection) {
    subscribe.findFeed.call(context);
  } else {
    openIndexedDB(subscribe.onOpenDatabase.bind(context));
  }
};

subscribe.onOpenDatabase = function(connection) {
  if(connection) {
    this.connection = connection;
    subscribe.findFeed.call(this);
  } else {
    subscribe.onComplete.call(this, {'type': 'ConnectionError'});
  }
};

subscribe.findFeed = function() {
  console.debug('Checking if subscribed to feed with url',
    this.feed.getURL().toString());
  // Before involving any network overhead, check if already subscribed. This
  // check will implicitly happen again later when inserting the feed into the
  // database, so it is partially redundant, but it can reduce the amount of
  // processing in the common case.
  // This uses a separate transaction from the eventual add request, because
  // it is not recommended to have a long running transaction, and the amount of
  // work that has to occur between this exists check and the add request takes
  // a somewhat indefinite period of time, given network latency.
  // This does involve a race condition if calling subscribe concurrently on
  // the same url, but its impact is limited. The latter http request will use
  // the cached page, and the latter call will fail with a ConstraintError when
  // trying to add the feed.
  const transaction = this.connection.transaction('feed');
  const store = transaction.objectStore('feed');
  const index = store.index('urls');
  const request = index.get(this.feed.getURL().toString());
  request.onsuccess = subscribe.findFeedOnSuccess.bind(this);
  request.onerror = subscribe.findFeedOnError.bind(this);
};

subscribe.findFeedOnSuccess = function(event) {

  // Callback with an error if already subscribed
  if(event.target.result) {
    console.debug('Already subscribed to', this.feed.getURL().toString());
    subscribe.onComplete.call(this, {'type': 'ConstraintError'});
    return;
  }

  // Otherwise, continue with the subscription
  if('onLine' in navigator && !navigator.onLine) {
    // Proceed with an offline subscription
    subscribe.addFeed.call(this, this.feed, subscribe.onAddFeed.bind(this));
  } else {
    // Online subscription. Verify the remote file is a feed that exists
    // and get its info
    const timeoutMillis = 10 * 1000;
    const excludeEntries = true;
    fetchFeed(this.feed.getURL(), timeoutMillis, excludeEntries,
      subscribe.onFetchFeed.bind(this));
  }
};

subscribe.findFeedOnError = function(event) {
  subscribe.onComplete.call(this, {'type': 'FindQueryError'});
};

subscribe.onFetchFeed = function(event) {
  if(event.type === 'load') {
    const feed = this.feed.merge(event.feed);
    subscribe.addFeed.call(this, feed, subscribe.onAddFeed.bind(this));
  } else {
    // Go to exit
    subscribe.onComplete.call(this, {'type': 'FetchError'});
  }
};

subscribe.addFeed = function(feed, callback) {
  console.debug('Adding feed', feed);
  console.assert(!feed.id, 'feed.id is defined', feed.id);
  let sanitizedFeed = feed.sanitize();
  sanitizedFeed.dateCreated = new Date();
  let serializedFeed = sanitizedFeed.serialize();

  const transaction = this.connection.transaction('feed', 'readwrite');
  const store = transaction.objectStore('feed');
  const request = store.add(serializedFeed);
  if(callback) {
    request.onsuccess = addOnSuccess;
    request.onerror = addOnError;
  }

  function addOnSuccess(event) {
    // Set the id generated by indexedDB
    serializedFeed.id = event.target.result;
    callback({'type': 'success', 'feed': serializedFeed});
  }

  function addOnError(event) {
    console.error(event);
    callback({'type': event.target.error.name});
  }
};

subscribe.onAddFeed = function(event) {
  if(event.type === 'success') {
    // Flag the subscription as successful
    this.didSubscribe = true;
    subscribe.onComplete.call(this, {'type': 'success', 'feed': event.feed});
  } else {
    // The add can fail for various reasons, such as a database error,
    // or because of a constraint error (feed with same url already exists)
    subscribe.onComplete.call(this, {'type': event.type});
  }
};

subscribe.onComplete = function(event) {
  if(this.closeConnection && this.connection) {
    this.connection.close();
  }

  if(!this.suppressNotifications && this.didSubscribe) {

    // TODO: if addFeed calls back with a Feed object, then I wouldn't need
    // to use call here

    notify('Subscription complete', 'Subscribed to ' + (event.feed.title ||
      Feed.prototype.getURL.call(event.feed).toString()));
  }

  if(this.callback) {
    this.callback(event);
  }
};




const unsubscribe = {};

unsubscribe.start = function(feedId, callback) {
  console.assert(feedId && !isNaN(feedId), 'invalid feed id', feedId);
  console.debug('Unsubscribing from feed with id', feedId);

  // Create a shared state for simple parameter passing to continuations
  const context = {
    'feedId': feedId,
    'deleteRequestCount': 0,
    'callback': callback
  };

  openIndexedDB(unsubscribe.onOpenDatabase.bind(null, context));
};

unsubscribe.onOpenDatabase = function(context, connection) {
  if(connection) {
    context.connection = connection;
    // Open a cursor over the entries for the feed
    const transaction = connection.transaction('entry', 'readwrite');
    const store = transaction.objectStore('entry');
    const index = store.index('feed');
    const request = index.openCursor(context.feedId);
    request.onsuccess = unsubscribe.onOpenCursor.bind(request, context);
    request.onerror = unsubscribe.onOpenCursor.bind(request, context);
  } else {
    unsubscribe.onComplete(context, 'ConnectionError');
  }
};

unsubscribe.onOpenCursor = function(context, event) {

  if(event.type === 'error') {
    console.error(event);
    unsubscribe.onComplete(context, 'DeleteEntryError');
    return;
  }

  const cursor = event.target.result;
  if(cursor) {
    const entry = cursor.value;
    // Delete the entry at the cursor (async)
    cursor.delete();
    // Track the number of delete requests
    context.deleteRequestCount++;

    // Async, notify interested 3rd parties the entry will be deleted
    chrome.runtime.sendMessage({
      'type': 'entryDeleteRequested',
      'entryId': entry.id
    });
    cursor.continue();
  } else {
    unsubscribe.onRemoveEntries(context);
  }
};

unsubscribe.onRemoveEntries = function(context) {
  console.debug('Deleting feed with id', context.feedId);
  const transaction = context.connection.transaction('feed', 'readwrite');
  const store = transaction.objectStore('feed');
  const request = store.delete(context.feedId);
  request.onsuccess = unsubscribe.deleteFeedOnSuccess.bind(request, context);
  request.onerror = unsubscribe.deleteFeedOnError.bind(request, context);
};

unsubscribe.deleteFeedOnSuccess = function(context, event) {
  unsubscribe.onComplete(context, 'success');
};

unsubscribe.deleteFeedOnError = function(context, event) {
  console.warn('Failed to delete feed with id %i, but may have deleted entries',
    context.feedId);
  unsubscribe.onComplete(context, 'DeleteFeedError');
};

unsubscribe.onComplete = function(context, eventType) {
  // Connection may be undefined such as when calling this as a result of
  // failure to connect
  if(context.connection) {

    // If connected, check if we actually affected the entry store
    if(context.deleteRequestCount) {
      console.debug('Requested %i entries to be deleted',
        context.deleteRequestCount);

      // Even though the deletes are async, the readonly transaction in
      // badge.update waits for the pending deletes to complete
      badge.update(context.connection);
    }

    context.connection.close();
  }

  // Callback with an event
  if(context.callback) {
    context.callback({
      'type': eventType,
      'feedId': context.feedId,
      'deleteRequestCount': context.deleteRequestCount
    });
  }
};
