// For importing feeds from opml file into the reader app

import assert from "/src/assert.js";
import FaviconCache from "/src/favicon-cache.js";
import * as FileUtils from "/src/file.js";
import * as idb from "/src/idb.js";
import * as mime from "/src/mime.js";
import {
  opmlRemoveOutlinesWithInvalidTypes,
  opmlNormalizeOutlineXMLURLs,
  opmlRemoveOutlinesMissingXMLURLs,
  opmlGetOutlineObjects,
} from "/src/opml-document.js";
import {
  normalizeHTMLURL as opmlOutlineNormalizeHTMLURL,
  toFeed as opmlOutlineToFeed
} from "/src/opml-outline.js";
import parseOPML from "/src/parse-opml";
import {promiseEvery} from "/src/promise.js";
import * as rdb from "/src/rdb.js";
import {SubscribeRequest} from "/src/subscribe-request.js";

// Import opml files
// @param files {FileList} a collection of File objects, such as one
// generated by an HTML input element after browsing for files
// @throws {AssertionError}
// @throws {Error} database related
export async function readerImportFiles(files) {
  assert(files instanceof FileList);
  console.debug('importing %d files', files.length);

  const fic = new FaviconCache();

  // TODO: revisit abbreviated destructuring syntax and use that instead of declaring and using
  // a "_" placeholder.

  let readerConn, _;
  try {
    [readerConn, _] = await Promise.all([rdb.open(), fic.open()]);

    const promises = [];
    for(const file of files) {
      promises.push(importFile(file, readerConn, fic.conn));
    }

    await promiseEvery(promises);
  } finally {
    fic.close();
    rdb.close(readerConn);
  }
}

// TODO: this should accept iconCache as parameter instead of iconConn. Then isOpenDb does not
// need to be used and can use iconCache.isOpen() instead, and then isOpenDb does not need to be
// imported as an explicit dependency, and iconCache fully encapsulates and serves as a better
// abstraction

async function importFile(file, readerConn, iconConn) {
  assert(file instanceof File);
  assert(rdb.isOpen(readerConn));
  assert(idb.isOpen(iconConn));
  console.log('importing opml file', file.name);

  if(file.size < 1) {
    console.log('file %s is 0 bytes', file.name);
    return 0;
  }

  if(!mime.isXML(file.type)) {
    console.log('file %s is not mime type xml', file.type);
    return 0;
  }

  let fileContent;
  try {
    fileContent = await FileUtils.readAsText(file);
  } catch(error) {
    console.warn(error);
    return 0;
  }

  const document = parseOPML(fileContent);

  // TODO: these 3 should be local function calls, these functions are currently defined in the
  // wrong module, because this functionality is unique to this module and not all opml documents

  opmlRemoveOutlinesWithInvalidTypes(document);
  opmlNormalizeOutlineXMLURLs(document);
  opmlRemoveOutlinesMissingXMLURLs(document);

  const outlines = opmlGetOutlineObjects(document);
  if(!outlines.length) {
    console.log('file %s contained 0 outlines', file.name);
    return 0;
  }

  const uniqueOutlines = groupOutlines(outlines);
  const dupCount = outlines.length - uniqueOutlines.length;
  console.log('found %d duplicates in file', dupCount, file.name);

  for(const outline of uniqueOutlines) {
    opmlOutlineNormalizeHTMLURL(outline);
  }

  const feeds = [];
  for(const outline of uniqueOutlines) {
    feeds.push(opmlOutlineToFeed(outline));
  }

  const request = new SubscribeRequest();
  request.readerConn = readerConn;
  request.iconConn = iconConn;
  request.timeoutMs = timeoutMs;
  request.notify = false;

  // Allow exceptions to bubble
  const subAllResults = await request.subscribeAll(feeds);
  console.log('subbed to %d feeds in file', subAllResults.length, file.name);
}

// Filter duplicates, favoring earlier in array order
function groupOutlines(outlines) {
  const uniqueURLs = [];
  const uniqueOutlines = [];
  for(const outline of outlines) {
    if(!uniqueURLs.includes(outline.xmlUrl)) {
      uniqueOutlines.push(outline);
      uniqueURLs.push(outline.xmlUrl);
    }
  }
  return uniqueOutlines;
}
