# write-entry
Creates or overwrites an entry object in the database.

If the goal is to create, the `id` property should not exist in the input object. Note the difference between an id property set to undefined, and the absence of the property.

In the case of creation the input entry is cloned in order to maintain some semblance of purity. In the case of update, the input entry is not cloned, and this function becomes slightly impure because it may set the id property to its same value. Of course, there is a database modification, so the function is fundamentally impure in the end.

### Context properties
* **conn** {IDBDatabase} an open database connection
* **channel** {BroadcastChannel} after successful storage a message is posted to the channel with type and id properties
* **console** {Object} logging destination, anything console-like

All properties are required.

### Params
* **entry** {object} required, the entry to update
* **validate** {Boolean} whether to validate the input object, optional, defaults to true

The input entry object must be *structured-cloneable*, which basically means serializable, which basically means it must be a basic object and not a function object. Otherwise this will throw an error when attempting to store the object in indexedDB.

### Errors
* **DOMException** when a database error occurs, such as when using a bad id value, or creating a new entry that shares a url with an existing entry, or the database is closing at the time the transaction is started
* **TypeError** invalid input parameters
* **InvalidStateError** channel is closed when posting message

Beware the following caveat: in the event of a database error the database remains in the state prior to calling `write_entry`, because the transaction never commits. In the event of a channel post error *the database is still modified*. In other words `write_entry` can fail with an error but still permanently modify the database.

### Return value
Returns a promise that resolves to the stored entry object.

Resolution occurs only after the internal transaction commits. In other words this does not use eventual-consistency and prematurely resolve. At least not in Chrome's implementation of indexedDB. I think Firefox does some funky stuff where if the disk fails the transaction still commits because the internal transaction eagerly commits. However, that is in a lower layer, and not something I can do much about.

For created entries, this retrieves the new id generated by indexedDB and sets the id property of the returned entry object.

### TODOs
* Validation shouldn't throw an exception. Data is routinely bad. Bad data is not a program error. Exceptions should be reserved for programming errors. But what else is there to do in this case? And which module or step in the entry-processing-pileine is responsible for ensuring the input data is ever good? How do I differentiate between code earlier in the execution path being poorly written, and bad data?
* If I plan to have validation also occur in `entry_sanitize`, then I think what should happen here is that I pass a `validate` flag (boolean, set to false) along to `entry_sanitize` to avoid revalidation because it could end up being a heavier operation, basically I am undecided about where validation should occur, and if I end up doing validation in multiple places I am concerned about redundant validation. If I add validation to sanitize, I could just forward the flag. But there is a problem there, because I do not do sanitization in the case of an update, only in the case of create. The hierarchy of conditions grows a bit and may be too deep.
* It is possible this would be better implemented if it was not concerned with validation or sanitization at all. I think it might be an anti-pattern.

Regarding above, consider the following code:

```
function first_caller() {
  foo();
  bar();
}

function second_caller() {
  const do_foo = true;
  bar(do_foo);
}

function foo() {}

function bar(do_foo) {
  if(do_foo) {
    foo();
  }

  ...
}
```

Basically the `do_foo` flag is dumb. The caller can decide whether foo should occur simply by either calling it or not calling it. Then bar is no longer concerned with whether foo occurs. Basically the bar(do_foo) implementation is abusing flag parameters to decide the flow of execution. Flag parameters should probably generally not decide execution flow. Instead the caller decides this, both explicitly and implicity, by the presence or absence of the foo call preceding bar.

The fact that `do_foo` is boolean, meaning that it *could* be false some of the time, means it is optional. This means foo is not tightly coupled with bar, from a sequence-of-operations perspective. In other words the presence of bar does not imply foo. That is strong evidence that do_foo is bad as a parameter.

Removing `do_foo` removes the concern from bar about whether foo occurs. bar is free to concern itself with only its purpose and it becomes simpler. This is particularly true in the case where foo is optional and doesn't really affect bar's logic, just its flow.

Again, go back to the idea of composable functions. The caller can choose to compose foo and bar by calling foo then calling bar. If do_foo is a parameter, then the caller can still compose but is forced to do so via parameter instead of by explicit call. So it is almost like I am ignoring the built in freedom of the language. This seems universal, so it really seems like a violation of a basic programming rule.
